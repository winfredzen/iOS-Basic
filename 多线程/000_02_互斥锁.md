# 互斥锁

维基百科对[互斥锁](https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81)的解释：

> **互斥锁**（英语：Mutual exclusion，缩写 Mutex）是一种用于[多线程](https://zh.wikipedia.org/wiki/多线程)[编程](https://zh.wikipedia.org/wiki/编程)中，防止两条[线程](https://zh.wikipedia.org/wiki/线程)同时对同一公共资源（比如[全局变量](https://zh.wikipedia.org/wiki/全域變數)）进行读写的机制。该目的通过将代码切片成一个一个的[临界区域](https://zh.wikipedia.org/wiki/临界区域)（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。



**互斥锁vs自旋锁**

| 锁名   | 作用                                                         |
| :----- | :----------------------------------------------------------- |
| 互斥锁 | 当某个资源被先进入的线程上了锁以后，其它后面进入的线程会**进入休眠状态**。当锁释放后，进入休眠状态的线程变为唤醒状态。 |
| 自旋锁 | 当某个资源被先进入的线程上了锁以后，其它后进入的线程会开启一个**循环**，不断检查锁有没有释放，当锁释放后，退出循环开始访问资源，整个过程中后进入的线程一直**保持运行状态**。 |

参考：

+ [互斥锁和自旋锁的区别](https://www.cnblogs.com/LiuYanYGZ/p/12739614.html)

> 自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。其作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它也有些不足之处：
>   1、自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。
>   2、在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能造成死锁，如 copy_to_user()、copy_from_user()、kmalloc()等。