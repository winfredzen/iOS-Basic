# 编译与链接

内容来自：《程序员的自我修养》



IDE一般将编译和链接的过程一步完成，称为构建**Build**



## 隐藏的过程

如下简答的C程序hello.c：

```c
#include <stdio.h>
int main()
{
    printf("Hello World\n");
    return 0;
}
```

GCC编译时

```shell
gcc hello.c
./a.out
Hello World
```

事实上上面的步骤可以分为4个步骤

+ 预处理（Prepressing）
+ 编译（Compilation）
+ 汇编（Assembly）
+ 链接（Linking）

![001](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/001.png)



### 预编译

预编译过程主要处理源代码文件中以"#"开始的预编译指令，比如`#include` 、` #define`等

+ 将所有`#define`删除，并且展开所有的宏定义。
+ 处理所有的条件预编译指令，如`#if #ifdef #eif #else #endif`
+ 处理`#include`预编译指令，将被包含的文件Haru到预编译指令的位置。**这个过程可能是一个递归的过程，有可能文件中还包含其他文件**。
+ 删除所有的注释
+ 添加行号及文件标识符。如`# 2 "hello.c" 2`，用于编译器编译时产生调试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号
+ 保留所有的#pragma编译指令，编译器需要

预编译的过程相当于

```sh
gcc -E hello.c -o hello.i
```

输出的`hello.i`大概有500多行，内容如下：

![002](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/002.png)



### 编译

编译过程就是把预处理完的文件进行一些列词法分析、语法分析、语法分析及优化后生成相应的汇编代码文件

```shell
gcc -S hello.c -o hello.s
```

`hello.s`内容大致如下:

![003](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/003.png)



### 汇编

汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令

```shell
gcc -c hello.c -o hello.o
```

> gcc命令从C源代码文件开始，经过预编译、编译和汇编直接输出**目标文件**（Object File）

`hello.o`文件内容大致如下：

![004](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/004.png)



### 链接

为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？为什么要链接？

看看怎样调用`ld`才可以产生一个能够正常运行的HelloWorld程序：

![005](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/005.png)

可以看到，需要将一大堆文件链接起来才可以得到`"a.out"`，即最终的可执行文件



## 编译器做了什么

编译过程一般可分为：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化

![006](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/006.png)



如下的C语言的源代码`CompilerExpression.c`：

```c
array[index] = (index + 4) * (2 + 6)
```



### 词法分析

源代码被输入到**扫描器**（Scanner），扫描器的任务很简单，它只是简答进行词法分析，运用一种类似于**有限状态机**（Finite State Machine）的算法可以很轻松地将源代码的字符序列分割成一系列**记号**（token）

上面的程序，经过扫描以后，产生了16个记号

![007](https://github.com/winfredzen/iOS-Basic/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/images/007.png)

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字符串）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也完成了其它工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用



### 语法分析





























