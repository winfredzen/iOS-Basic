# ARC原理

参考：

+ [理解 iOS 的内存管理](https://blog.devtang.com/2016/07/30/ios-memory-management/)
+ [iOS面试题：简述ARC 以及 ARC 实现的原理](https://my.oschina.net/u/4002983/blog/3102948)
+ [ Objective-C 中的内存分配](https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html)



## Effective Objective-C 2.0书籍内容

> 保留计数将至0，那么number对象所占内存也许会回收，这样的话，再调用NSLog可能就将使程序崩溃了。这里只说“可能”，而没说“一定”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”(avaiable pool)。如果执行NSLog时尚未写对象内存，那么改对象任然有效，这时程序不会崩溃

> **属性存取方法中的内存管理**
>
> 先将新值retain，再释放旧值，然后更新实例变量。（两个值可能指向同一对象）

> 注意**retain cycle**



### ARC

> 在编译期，ARC会把能够相互抵消的retain、release、autorelease操作简约。如果发现在同一个对象上执行了多次“保留”与“释放”操作，那么ARC有时可以成对的移除这两个操作

> ARC可以在运行期检测到这一对多余的操作，也就是autorelease及紧跟其后的retain。为例优化代码，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的autorelease方法，而是调用`objc_autoreleaseReturnValue`。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码要在返回的对象上执行`retain`操作，这设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位，而不执行保留此对象，那么此时不直接执行retain，而是改为执行`objc_retainAutoreleaseReturnValue`函数。此函数要检测刚才提到的那个标志位，若已经置位，这不执行retain操作。设置并检测标志位，要比调用autorelease和retain要快

> ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作