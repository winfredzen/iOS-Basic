# 队列

队列(Queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表

队列是一种先进先出(First In First Out)的线性表，简称**FIFO**

如下，定义一个协议：

```swift
public protocol Queue {
    associatedtype Element
    mutating func enqueue(_ element: Element) -> Bool
    mutating func dequeue() -> Element?
    var isEmpty: Bool { get }
    var peek: Element? { get }
}
```

实现队列有多种形式，如：

+ 使用数组
+ 使用双向链表(double linked list)
+ 使用[ring buffer](<https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80>)

+ 使用2个栈

**1.数组实现**

```swift
public protocol Queue {
    associatedtype Element
    mutating func enqueue(_ element: Element) -> Bool
    mutating func dequeue() -> Element?
    var isEmpty: Bool { get }
    var peek: Element? { get }
}

public struct QueueArray<T>: Queue {
    private var array: [T] = []
    public init () {}
    
    public var isEmpty: Bool {
        return array.isEmpty // 检查队列是否为空
    }
    
    public var peek: T? {
        return array.first // 返回最前面的元素
    }
    
    public mutating func enqueue(_ element: T) -> Bool {
        array.append(element)
        return true
    }
    
    public mutating func dequeue() -> T? {
        return isEmpty ? nil : array.removeFirst()
    }
}

extension QueueArray: CustomStringConvertible {
    public var description: String {
        return String(describing: array)
    }
}

```

优缺点

|    操作     |                     最好情况                     |                     最坏情况                     |
| :---------: | :----------------------------------------------: | :----------------------------------------------: |
| enqueue(_:) | ![001](http://latex.codecogs.com/gif.latex?O(1)) | ![001](http://latex.codecogs.com/gif.latex?O(1)) |
| dequeue(_:) | ![001](http://latex.codecogs.com/gif.latex?O(n)) | ![001](http://latex.codecogs.com/gif.latex?O(n)) |
| 空间复杂度  | ![001](http://latex.codecogs.com/gif.latex?O(n)) | ![001](http://latex.codecogs.com/gif.latex?O(n)) |

缺点是：元素出列时，所有的元素都需要偏移一个位置

**2.使用双向链表**

```swift
public class QueueLinkedList<T>: Queue {
    private var list = DoublyLinkedList<T>()
    public init() {}
    
    public func enqueue(_ element: T) -> Bool {
        list.append(element)
        return true
    }
    
    public func dequeue() -> T? {
        guard !list.isEmpty, let element = list.first else {
            return nil
        }
        return list.remove(element)
    }
    
    public var peek: T? {
        return list.first?.value
    }
    
    public var isEmpty: Bool {
        return list.isEmpty
    }
}

extension QueueLinkedList: CustomStringConvertible {
    public var description: String {
        return String(describing: list)
    }
}
```

优缺点

|    操作     |                     最好情况                     |                     最坏情况                     |
| :---------: | :----------------------------------------------: | :----------------------------------------------: |
| enqueue(_:) | ![001](http://latex.codecogs.com/gif.latex?O(1)) | ![001](http://latex.codecogs.com/gif.latex?O(1)) |
| dequeue(_:) | ![001](http://latex.codecogs.com/gif.latex?O(1)) | ![001](http://latex.codecogs.com/gif.latex?O(1)) |
| 空间复杂度  | ![001](http://latex.codecogs.com/gif.latex?O(n)) | ![001](http://latex.codecogs.com/gif.latex?O(n)) |

`QueueArray`的缺点是出列是线性时间。使用双向链表后，出列时间为常量![001](http://latex.codecogs.com/gif.latex?O(1))，你所需要做的就是更新结点的`previous`和`next`的指针

`QueueLinkedList`的缺点就是，每个结点需要额外的存储空间来存储向前和向后的引用。每次创建一个新的元素时，相对来说需要更多的内存分配