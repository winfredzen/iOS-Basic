# 闭包

参考文档：

+ [Closures in Swift](https://medium.com/the-andela-way/closures-in-swift-8aef8abc9474)
+ [闭包](https://www.cnswift.org/closures#spl-8)



1.闭包可以捕获上下文中定义的常量和变量

参考，Swift文档中的内嵌函数，如下的内嵌函数：

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

`incrementer()`没有任何的形式参数，但它通过捕获主函数的`runningTotal`和`amount`，在自身内部使用。

当调用`makeIncrementer`结束时引用捕获并不会消失，所以下次再调用`incrementer`时，`runningTotal`将会继续增加

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)

incrementByTen() //10
incrementByTen() //20
incrementByTen() //30
```

2.闭包的参数是常量，不可以修改，除非使用`in-out`

如下的例子：

```swift
var closure: (String) -> String = { someString in
    return someString = "hey"
}
```

会提示错误：

```swift
error: Closure.playground:16:23: error: cannot assign to value: 'someString' is a 'let' constant
    return someString = "hey"
           ~~~~~~~~~~ ^
```

如果将其参数用`in-out`来修饰，则不会提示出错：

```swift
var closure: (inout String) -> String  = { someString in
    someString = "hey"
    return someString
}
```

3.闭包是引用类型



## 逃逸闭包

逃逸：当闭包作为一个实际参数传递给一个函数的时候，就说这个闭包*逃逸*了，因为它可以在函数返回之后被调用

在形式参数前加上`@escaping`来明确闭包是允许逃逸的

参考：[What do mean @escaping and @nonescaping closures in Swift?](https://medium.com/@kumarpramod017/what-do-mean-escaping-and-nonescaping-closures-in-swift-d404d721f39d)

> In Swift 1 and Swift 2, closure parameters was **escaping** by default. Your closure wouldn’t be escape the function’s body, if no you could mark the closure parameters as **@nonescaping**.
>
> 在Swift 1和Swift 2中，闭包默认是逃逸的
>
> In Swift 3, they made a change: closure parameters are **no-escaping** by default, if you wanna to escape the closure execution, you have to use **@escaping** with the closure parameters. 
>
> 而在Swift 3中，闭包默认是非逃逸的

逃逸闭包使用的场景：

+ **Storage** - 将闭包保存起来，以后再使用
+ **Asynchronous Execution** - 异步执行

例子1，**Storage**：

```swift
var complitionHandler: ((Int)->Void)?
func getSumOf(array:[Int], handler: @escaping ((Int)->Void)) {
    //step 2
    //here I'm taking for loop just for example, in real case it'll be something else like API call
    var sum: Int = 0
    for value in array {
        sum += value
    }
    //step 3
    self.complitionHandler = handler
}

func doSomething() {
    //setp 1
    self.getSumOf(array: [16,756,442,6,23]) { (sum) in
        print(sum)
        //step 4, finishing the execution
    }
}
```

例子2，**Asynchronous Execution**

```swift
func getSumOf(array:[Int], handler: @escaping ((Int)->Void)) {
    //step 2
    var sum: Int = 0
    for value in array {
        sum += value
    }
    //step 3
    Globals.delay(0.3, closure: {
        handler(sum)
    })
}

func doSomething() {
    //setp 1
    self.getSumOf(array: [16,756,442,6,23]) { (sum) in
        print(sum)
        //step 4, finishing the execution
    }
}
```



> **让闭包 @escaping 意味着你必须在闭包中显式地引用 self** 



## 自动闭包

`@autoclosure` 标志标记它的形式参数使用了自动闭包

如下的官方例子，`serve(customer:)`要接受一个闭包：

```swift
// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) } )
// Prints "Now serving Alex!"
```

使用自动闭包，如下，并不用显式的传递一个闭包：

```swift
// customersInLine is ["Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
// Prints "Now serving Ewa!"
```

一些说明：

+ `{ customersInLine.remove(at: 0) }`为闭包，注意下区别







