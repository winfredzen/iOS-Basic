# C++类基础



## 访问权限

参考：

+ [C++类成员的访问权限](http://c.biancheng.net/cpp/biancheng/view/2970.html)



C++通过 `public`、protected、`private` 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为`成员访问限定符`

> C++ 中的 `public`、`private`、`protected` 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。



+ 在类的外部，只能访问 `public` 属性的成员，不能访问 `private`、`protected` 属性的成员



## 定义与创建

参考：

+ [C++类的定义和对象的创建](http://c.biancheng.net/cpp/biancheng/view/185.html)



两种创建对象的方式：

+ 一种是在栈上创建，形式和定义普通变量类似；通过对象名字访问成员使用点号`.`
+ 一种是在堆上创建，必须要用一个指针指向它，读者要记得 `delete` 掉不再使用的对象。通过对象指针访问成员使用箭头`->`



类定义的最后有一个分号`;`，它是类定义的一部分，表示类定义结束了，不能省略。否则会提示错误

![006](https://github.com/winfredzen/iOS-Basic/blob/master/C%2B%2B/images/006.png)



> 成员变量大都以`m_`开头，这是约定成俗的写法，不是语法规定的内容。以`m_`开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。

> 给成员变量赋值的函数通常称为 set 函数，它们的名字通常以`set`开头，后跟成员变量的名字；读取成员变量的值的函数通常称为 get 函数，它们的名字通常以`get`开头，后跟成员变量的名字。



### 创建对象

可以使用点号`.`来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似

![007](https://github.com/winfredzen/iOS-Basic/blob/master/C%2B%2B/images/007.png)

创建对象数组：

```c++
Student allStu[100];
```



### 使用指针

创建的对象 `stu` 在栈上分配内存，需要使用`&`获取它的地址，例如：

```c++
Student stu;
Student *pStu = &stu;
```

也可以在堆上创建对象，这个时候就需要使用`new`关键字

```c++
Student *pStu = new Student;
```

> 在**栈**上创建出来的对象都有一个名字，比如 `stu`，使用指针指向它不是必须的。但是通过 `new` 创建出来的对象就不一样了，它在**堆**上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 `new` 在**堆**上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。



> **栈**内存是程序自动管理的，不能使用 `delete` 删除在栈上创建的对象；**堆**内存由程序员管理，对象使用完毕后可以通过 `delete` 删除。在实际开发中，`new` 和 `delete` 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。



```c++
#include <iostream>
#include "Student.h"

int main(int argc, const char * argv[]) {
    
    Student *stu = new Student;
    stu -> age = 18;
    stu -> name = "wz";
    stu -> score = 100;
    stu -> say();
    delete stu;
    
    return 0;
}

```



### 成员变量与成员函数

参考：

+ [C++类的成员变量和成员函数](http://c.biancheng.net/cpp/biancheng/view/186.html)



将函数定义放在类体外面，使用`::`域解析符，用来连接类名和函数名，指明当前函数属于哪个类

```c++
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;
    //成员函数
    void say();  //函数声明
};
//函数定义
void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```



## 构造函数

+ 名字和类名相同
+ 没有返回值

参考：

+ [C++构造函数（Constructor）](http://c.biancheng.net/cpp/biancheng/view/192.html)



```c++
#include <iostream>
using namespace std;

class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    //声明构造函数
    Student(char *name, int age, float score);
    //声明普通成员函数
    void show();
};

//定义构造函数
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
//定义普通成员函数
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    //创建对象时向构造函数传参
    Student stu("小明", 15, 92.5f);
    stu.show();
    //创建对象时向构造函数传参
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```



### 默认构造函数

如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。比如上面的 Student 类，默认生成的构造函数如下：

```c++
Student(){}
```

**调用没有参数的构造函数也可以省略括号**

> 在栈上创建对象可以写作`Student stu()`或`Student stu`，在堆上创建对象可以写作`Student *pstu = new Student()`或`Student *pstu = new Student`，它们都会调用构造函数 `Student()`。





### C++构造函数的参数初始化表

参考：

+ [C++构造函数的参数初始化表](http://c.biancheng.net/cpp/biancheng/view/2979.html)

```c++
#include <iostream>

using namespace std;

class Student {
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    Student(char *name, int age, float score);
    void show();
};

//采用参数初始化表
Student::Student(char *name, int age, float score) : m_name(name), m_age(age), m_score(score) {
    
}

void Student::show() {
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(int argc, const char * argv[]) {
    Student stu("小明", 15, 92.5f);
    stu.show();
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();
    return 0;
}
```

> 在函数首部与函数体之间添加了一个冒号`:`，后面紧跟`m_name(name), m_age(age), m_score(score)`语句，这个语句的意思相当于函数体内部的`m_name = name; m_age = age; m_score = score;`语句，也是赋值的意思。

参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。

```c++
Student::Student(char *name, int age, float score): m_name(name){
    m_age = age;
    m_score = score;
}
```

**注意，参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关**



#### 初始化 const 成员变量

**初始化 const 成员变量的唯一方法就是使用参数初始化表**

```c++
class VLA {
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};

//必须使用参数初始化表来初始化 m_len
VLA::VLA(int len) : m_len(len) {
    m_arr = new int[len];
}
```



## 析构函数

参考：

+ [C++析构函数（Destructor）](http://c.biancheng.net/cpp/biancheng/view/196.html)



析构函数前面添加`~`符号

```c++
class VLA{
public:
    VLA(int len);  //构造函数
    ~VLA();  //析构函数
```

































