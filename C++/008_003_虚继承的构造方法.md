# 虚继承的构造方法

在虚继承中，最终派生类的构造函数必须要调用虚基类的构造函数

以下图为例：

![009](https://github.com/winfredzen/iOS-Basic/blob/master/C%2B%2B/images/009.jpg)

则必须调用`A`的构造方法，如下的例子：

```c++
#include <iostream>

using namespace std;

//虚基类A
class A{
public:
    A(int a);
protected:
    int m_a;
};
A::A(int a): m_a(a){ }

//直接派生类B
class B: virtual public A{
public:
    B(int a, int b);
public:
    void display();
protected:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<endl;
}

//直接派生类C
class C: virtual public A{
public:
    C(int a, int c);
public:
    void display();
protected:
    int m_c;
};
C::C(int a, int c): A(a), m_c(c){ }
void C::display(){
    cout<<"m_a="<<m_a<<", m_c="<<m_c<<endl;
}

//间接派生类D
class D: public B, public C{
public:
    D(int a, int b, int c, int d);
public:
    void display();
private:
    int m_d;
};
D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d){ }
void D::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<", m_c="<<m_c<<", m_d="<<m_d<<endl;
}
int main(){
    B b(10, 20);
    b.display();
   
    C c(30, 40);
    c.display();
    D d(50, 60, 70, 80);
    d.display();
    return 0;
}
```

控制台输出结果如下：

```c++
m_a=10, m_b=20
m_a=30, m_c=40
m_a=50, m_b=60, m_c=70, m_d=80
```



在上面的例子中，`D`的构造方法如下：

```c++
D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d){ }
```

在创建`D d(50, 60, 70, 80);`时，控制台输出`m_a=50`，对比上面的构造方法，可见：

> 调用 `B` 的构造函数时试图将 `m_a` 初始化为 `90`，调用 `C` 的构造函数时试图将 `m_a` 初始化为 `100`，但是输出结果有力地证明了这些都是无效的，`m_a` 最终被初始化为 `50`，这正是在 `D` 中直接调用 `A` 的构造函数的结果



**构造函数的执行顺序**

虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器**总是先调用虚基类的构造函数**，**再按照出现的顺序调用其他的构造函数**；而对于普通继承，就是按照构造函数出现的顺序依次调用的。

修改本例中第 50 行代码，改变构造函数出现的顺序：

```c++
D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d){ }
```

虽然我们将 `A()` 放在了最后，但是编译器仍然会先调用 `A()`，然后再调用 `B()`、`C()`，因为 `A()` 是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用 `B()`、`C()`、`A()`















